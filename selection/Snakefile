

# Configuration for the selection is in an independent file
import yaml

#Load eos paths (restripped or usual tuples)
if config['stripping_mode']=='pidcuts':
  with open('selection/config.yaml') as file:
    selconfig = yaml.load(file, Loader=yaml.FullLoader)

elif config['stripping_mode']=='nopidcuts':
  with open('selection/config_restripped.yaml') as file:
    selconfig = yaml.load(file, Loader=yaml.FullLoader)


include: 'helpers.smk'
include: 'bdt/Snakefile'
include: 'LbBKG/Snakefile'
# include: 'Snakefile-Bs2DsPi'


# some extra helpers {{{

def cut_keys_mode(wildcards):
    """
    Define cut keys to be applied if not all. 
    Only exception at the moment is DsPi.
    """
    if 'Bs2DsPi' not in wildcards.mode: 
       return 'B_TAU_cuts L0_cuts HLT1_cuts HLT2_cuts B_cuts phi_cuts'
 
    return 'all'


def grid_tuples(wcs):
    """
    List tuples in grid

    Parameters
    ----------
    wcs : dict
        Wildcards from a snakemake rule

    Output
    ------
    list[str]
        List of strings to XRootD files in grid
    """
    mode = wcs.mode
    year = wcs.year
    if 'MC' in wcs.mode:
        loc = 'eos_mc'
        _t = selconfig[loc][mode][int(year)][wcs.strip_sim][wcs.polarity]
    else:
        loc = 'eos_data'
        _t = selconfig[loc][selconfig['streams'][mode]][int(year)]
    _t = _t.split(' ')
    return [XRootD.remote(__t) for __t in _t]

# }}}


# Preselection Data {{{

if config['run_preselection'] and config['run_pid']:
    rule preselection_data:
        """
        Generic rule.
        Apply cuts specified in input yaml files on the given tree and adds branches
        specified in the corresponding yaml file. Saves new tree in the requested location

        WARNING: This rule is directly fed from Grid tuples
        """
        threads: 2
        resources:
            mem_mb = 6000
        wildcard_constraints:
            mode = "(Bs2JpsiPhi|Bd2JpsiKstar|Bu2JpsiKplus|Bs2JpsiPhi_Lb)"
        input:
            # files = lambda wcs: grid_tuples(wcs)
            # files = '/scratch46/marcos.romero/sidecar14/{year}/{mode}_{strip_sim}_pidcorrected.root'
        output:
            SAMPLES + '/{year}/{mode}/{version}_preselected.root'
        log:
            'output/log/selection_preselection/{year}/{mode}/{version}.log'
        params:
            script = 'selection/tools/apply_selection.py',
            cuts = 'selection/cuts.yaml',
            branches = 'selection/branches.yaml',
            cut_keys = cut_keys_mode,
            files = lambda wildcards: selconfig['eos_data'][selconfig['streams'][wildcards.mode]][int(wildcards.year)],
            treename = lambda wildcards: selconfig['treenames'][wildcards.mode]
        run:
            shell('(time python {params.script}\
            --input-file {params.files} \
            --input-tree-name {params.treename} \
            --output-file {output} \
            --mode {wildcards.mode} \
            --cut-keys {params.cut_keys} \
            --selection-files {params.cuts} \
            --branches-files {params.branches} \
            --year {wildcards.year}) &> {log}')

# }}}


# Prepare MC tuple {{{

if config['run_preselection']:
    rule preselection_prepare_mc:
        """
        Generic rule.
        Do not apply cuts, only add branches specified in the corresponding yaml
        file and save new tree in the requested location
        """
        wildcard_constraints:
            mode  = "(MC)((?!.*?(_fromLb)).*)"
        threads: 2
        resources:
            mem_mb = 6000
        output:
            SAMPLES + '/{year}/{mode}/{version}_{strip_sim}_prepared{polarity}.root',
        params:
            files = lambda wildcards: selconfig['eos_mc'][wildcards.mode][int(wildcards.year)][wildcards.strip_sim][wildcards.polarity],
            script = 'selection/tools/apply_selection.py',
            branches = ['selection/branches.yaml', 'selection/generator_level_branches_to_be_merged.yaml'],
            treename = lambda wildcards: selconfig['treenames'][wildcards.mode]
        log:
            'output/log/preselection_prepare_mc/{year}/{mode}/{version}_{strip_sim}_prepared{polarity}.log'
        run:
            shell('(time python {params.script} \
            --input-file {params.files} \
            --input-tree-name {params.treename} \
            --output-file {output} \
            --mode {wildcards.mode} \
            --branches-files {params.branches} \
            --year {wildcards.year} ) &> {log}')


    rule preselection_prepare_genlvl:
        """
        Generic rule.
        Create tuple with generator level information, that contains only specified
        branches
        """
        threads: 2
        resources:
            mem_mb = 6000
        output:
            SAMPLES + '/{year}/{mode}/{version}_{strip_sim}_genlevel{polarity}.root',
        log:
            'output/log/prepare_genlvl_mc/{year}/{mode}/{version}_{strip_sim}_prepared{polarity}.log'
        params:
            files = lambda wildcards: selconfig['eos_mc'][wildcards.mode][int(wildcards.year)][wildcards.strip_sim][wildcards.polarity],
            script = 'selection/tools/apply_selection.py',
            branches = 'selection/generator_level_branches_to_be_created.yaml',
            gen_treename = lambda wildcards: selconfig['treenames'][wildcards.mode].replace('_Tuple/DecayTree','_MCTuple/MCTuple')
        run:
            shell('(time python {params.script} \
            --input-file {params.files} \
            --input-tree-name {params.gen_treename} \
            --output-file {output} \
            --output-tree-name MCTuple \
            --mode {wildcards.mode} \
            --branches-files {params.branches} \
            --year {wildcards.year} \
            ) &> {log}')


    rule preselection_add_genlvl_info:
        """
        Generic rule.
        Add generator level information to specified MC tuple from given tuple with
        generator level information (produced by `prepare_generator_level_tuple`)
        """
        threads: 2
        resources:
            mem_mb = 6000
        input:
            input_file = expand(rules.preselection_prepare_mc.output,
                                mode='{mode}', version='{version}', year='{year}',
                                strip_sim='{strip_sim}', polarity='{polarity}'),
            input_gen_file = expand(rules.preselection_prepare_genlvl.output,
                                    mode='{mode}', version='{version}',
                                    year='{year}', strip_sim='{strip_sim}',
                                    polarity='{polarity}'),
        params:
            script = 'selection/tools/add_generator_level_info.py',
            branches = 'selection/generator_level_branches_to_be_merged.yaml'
        output:
            file = SAMPLES + '/{year}/{mode}/{version}_{strip_sim}_pipas{polarity}.root',
            file_tmp = SAMPLES + '/{year}/{mode}/{version}_{strip_sim}_pipas{polarity}_tmp.root',
            # file = temp(tuples_path('{mode}/{year}/{strip_sim}/{mode}_{year}_{strip_sim}_{polarity}_selected_with_gen.root')),
            # file_tmp = temp(tuples_path('{mode}/{year}/{strip_sim}/{mode}_{year}_{strip_sim}_{polarity}_selected_with_gen_tmp.root'))
        log:
            'output/log/selection_prepare_mc/{year}/{mode}/{version}_{strip_sim}_prepared{polarity}.log'
        run:
            shell('(time python {params.script} \
            --input-file {input.input_file} \
            --input-gen-file {input.input_gen_file} \
            --output-file {output.file} \
            --output-file-tmp {output.file_tmp} \
            --mode {wildcards.mode} \
            --branches-files {params.branches} \
            ) &> {log}')

# }}}


# NOTE: Running PID corrections is an expensive computational task. That is why
#       this behaviour is disabled by default.
if config['run_pid']:
    include: 'pid/Snakefile'


# Preselection MC {{{

# rompe el pipeline
if config['run_pid'] and config['run_preselection']:
    rule preselection_merge_polarities:
        """
        Generic rule.
        Merges input root files using hadd command and saves the output to the
        given path.
        """
        wildcard_constraints:
            mode  = "(MC)((?!.*?(_fromLb)).*)"
        threads: 2
        resources:
            mem_mb = 6000
        input:
            expand(rules.preselection_correct_pid.output.file,
                version='{version}', mode='{mode}', strip_sim='{strip_sim}',
                year='{year}', polarity=selconfig['polarities'])
        output:
            # temp(tuples_path('{mode}/{year}/{strip_sim}/{mode}_{year}_{strip_sim}_selected_pidcorrected.root'))
            # ELMARCS
            SAMPLES + '/{year}/{mode}/{version}_{strip_sim}_pidcorrected.root'
        run:
            print(f'hadd {output} {input}')
            shell('hadd {output} {input}')


    rule preselection_mc:
        """
        Generic rule.
        Apply cuts specified in input yaml files on the given tree and adds branches
        specified jin the corresponding yaml file. Saves new tree in the requested location
        """
        threads: 2
        resources:
            mem_mb = 12000
        wildcard_constraints:
            mode  = "(MC)((?!.*?(_fromLb)).*)"
        input:
            script = 'selection/tools/apply_selection.py',
            #file = expand(rules.merge_polarities.output, mode='{mode}',
            #                                              year='{year}',
            #                                               strip_sim='{strip_sim}'),
            cuts = 'selection/cuts.yaml',
            file = SAMPLES + '/{year}/{mode}/{version}_{strip_sim}_pidcorrected.root',
        output:
            # tuples_path('{mode}/{year}/{strip_sim}/{mode}_{year}_{strip_sim}_pidcorrected_selected_preselected.root')
            file = SAMPLES + '/{year}/{mode}/{version}_{strip_sim}_beforeGBW.root',
        params:
            cut_keys = cut_keys_mode,
            # file = lambda wildcards: selconfig['eos'] + '/' + selconfig['version'] + '/PID/{}/{}_{}_{}_selected_pidcorrected.root'.format(wildcards.mode, wildcards.mode, wildcards.year, wildcards.strip_sim)
        log:
            # tuples_path('{mode}/{year}/{strip_sim}/{mode}_{year}_{strip_sim}_pidcorrected_selected_preselected.root')
            'output/log/preselection_mc/{year}/{mode}/{version}_{strip_sim}.log'
        run:
            shell('(time python {input.script} \
            --input-file {input.file} \
            --output-file {output} \
            --mode {wildcards.mode} \
            --selection-files {input.cuts} \
            --cut-keys {params.cut_keys} \
            --year {wildcards.year}) &> {log}')

# }}}


include: 'gb_weights/Snakefile'


# Merge strippings {{{

rule selection_add_arrays:
    threads: 2
    resources:
        mem_mb = 6000
    input:
        script  = 'selection/tools/add_arrays.py',
        files = lambda wildcards: expand(rules.selection_gbw_compute.output if wildcards.mode != 'MC_Bs2JpsiPhi_Prompt'
                                                                             else rules.apply_gb_weights_prompt.output, 
                                                                             mode=wildcards.mode, 
                                                                             strip_sim=wildcards.strip_sim, 
                                                           version=wildcards.version,
                                                                             year=wildcards.year),

        files_arrays = SAMPLES + '/{year}/{mode}/{version}_{strip_sim}_beforeGBW.root',
        # files_arrays = expand(rules.apply_preselection_mc.output, year='{year}',
        #                                                    mode='{mode}',
        #                                                    version='{version}',
        #                                                    strip_sim='{strip_sim}'), 
        variables = 'selection/array_branches.yaml' 
    output:
        file = SAMPLES + '/{year}/{mode}/{version}_{strip_sim}_witharrs.root',
        file_tmp = SAMPLES + '/{year}/{mode}/{version}_{strip_sim}_witharrs_tmp.root',
        # file = tuples_path('{mode}/{mode}_{strip_sim}_{year}_pid_gb_arr.root'),
        # file_tmp = temp(tuples_path('{mode}/{mode}_{strip_sim}_{year}_pid_gb_arr_tmp.root'))
    shell:
        'python {input.script} --input-file {input.files} \
                               --input-file-arrays {input.files_arrays} \
                               --variables-files {input.variables} \
                               --mode {wildcards.mode} \
                               --output-file {output.file} \
                               --output-file-tmp {output.file_tmp}'



# modes = ['MC_Bs2JpsiPhi', 'MC_Bs2JpsiPhi_Prompt']

rule selection_merge_strippings:
    threads: 2
    resources:
        mem_mb = 6000
    input:
        script = 'selection/tools/file_merger.py',
        input_files = lambda wildcards: expand(
                rules.selection_add_arrays.output.file if wildcards.mode == 'MC_Bs2JpsiPhi' or wildcards.mode == 'MC_Bs2JpsiPhi_Prompt'
                else rules.selection_gbw_compute.output, 
                                                                             mode=wildcards.mode, 
                                                                             version=wildcards.version, 
                                                                             strip_sim=selconfig['strip_sim'][wildcards.mode][wildcards.year],
                                                                             year=wildcards.year)
    output:
        # temp(tuples_path('{mode}/{mode}_{year}_pid_gb.root'))
        # >>> file = SAMPLES + '/{year}/{mode}/{version}_pidgb.root',
        file = SAMPLES + '/{year}/{mode}/{version}_preselected.root',
    shell:
        'python {input.script} --input-files {input.input_files} \
                               --output-file {output}'

# }}}


# Merge PID corrected {{{

def all_strippings(wildcards):
    strippings = selconfig['strip_sim'][wildcards.mode][wildcards.year]
    mode = wildcards.mode
    year = wildcards.year
    version = wildcards.version

    files = []
    for strip_sim in strippings:
        # files.append(selconfig['eos'] + '/' + selconfig['version'] + '/PID/{}/{}_{}_'.format(wildcards.mode, wildcards.mode, wildcards.year) + s + '_selected_pidcorrected.root')
        files.append(SAMPLES + f'/{year}/{mode}/{version}_{strip_sim}_pidcorrected.root')

    return ' '.join(files)

rule preselection_merge_pid_corrected:
    """
    Generic rule.
    Merges input root files after applying PID correction using hadd command and saves the output to the
    given path.
    """
    threads: 2
    resources:
        mem_mb = 6000
    input:
        files = all_strippings
    output:
        # tuples_path('{mode}/{mode}_{year}_pid.root')
        SAMPLES + '/{year}/{mode}/{version}_pid.root',
    shell:
        'hadd {output} {input.files}'

# }}}


# Apply VETO {{{

def input_to_background_veto(wildcards):
    return expand(rules.apply_bdt_selection.output,
                  version=wildcards.version, mode=wildcards.mode,
                  year=wildcards.year)

rule selection_apply_veto:
    """
    Generic rule.
    Apply cuts in `cuts.yaml` to veto peaking background
    Saves new tree in the requested location
    """
    threads: 2
    resources:
        mem_mb = 6000
    input:
        # files = input_to_background_veto,
        files = SAMPLES + '/{year}/{mode}/{version}_elected.root',
        script = 'selection/tools/apply_selection.py',
        cuts = 'selection/cuts.yaml'
    output:
        SAMPLES + '/{year}/{mode}/{version}_selected.root'
    log:
        'output/log/selection_apply_veto/{year}/{mode}/{version}_selected.log'
    run:
        shell('(time python {input.script} \
        --input-file {input.files} \
        --input-tree-name DecayTree \
        --output-file {output} \
        --mode {wildcards.mode} \
        --selection-files {input.cuts} \
        --year {wildcards.year}) &> {log}')

# }}}


# TO BE DELETED {{{

# rule select_jpsikstar_mc_for_prefit_acc:
#     """
#     Select B0->J/psiK* MC to determine Ipatia tail parameters for
#     the fit to data. It only takes B_BKGCAT=0,50 events.
#     """
#     input:
# #        root_file = expand(rules.apply_background_veto.output, mode='MC_Bd2JpsiKstar',
# #                                                             year='{year}'),
#         script = 'selection/tools/apply_selection.py',
#         cuts = 'time_acceptance/cuts.yaml'
#     output:
#         temp(tuples_path('{mode}/{mode}_{year}_mc_for_prefit_acc.root'))
#     params:
#         root_file = lambda wildcards: selconfig['eos'] + '/' + selconfig['version'] + '/{}/{}/{}_{}_selected_bdt_{}.root'.format('MC_Bd2JpsiKstar', wildcards.year, 'MC_Bd2JpsiKstar', wildcards.year, selconfig['version'])
#     shell:
#         'python {input.script} --input-file {params.root_file} \
#                                --output-file {output} \
#                                --mode {wildcards.mode} \
#                                --selection-files {input.cuts} \
#                                --year {wildcards.year}'
#
# rule select_jpsikstar_data_for_acc:
#     """
#     Select B0->J/psiK* data for time acceptance.
#     """
#     input:
# #        root_file = expand(rules.apply_background_veto.output, mode='Bd2JpsiKstar',
# #                                                             year='{year}'),
#         script = 'selection/tools/apply_selection.py',
#         cuts = 'time_acceptance/cuts.yaml'
#     output:
#         temp(tuples_path('{mode}/{mode}_{year}_data_for_acc.root'))
#     params:
#         root_file = lambda wildcards: selconfig['eos'] + '/' + selconfig['version'] + '/{}/{}/{}_{}_selected_bdt_{}.root'.format('Bd2JpsiKstar', wildcards.year, 'Bd2JpsiKstar', wildcards.year, selconfig['version'])
#     shell:
#         'python {input.script} --input-file {params.root_file} \
#                                --output-file {output} \
#                                --mode {wildcards.mode} \
#                                --selection-files {input.cuts} \
#                                --year {wildcards.year}'
#
#
# rule mass_prefit_jpsikstar_mc:
#     """
#     Run mass fit on selected B0->J/psiK* MC to determine Ipatia tail parameters for
#     the fit to data. It only takes B_BKGCAT=0,50 candidates.
#     """
#     input:
#         script = 'selection/tools/mass_fit_ipatia.py',
#         root_file = expand(rules.select_jpsikstar_mc_for_prefit_acc.output, mode='MC_Bd2JpsiKstar',
#                                                                             year='{year}')
#     output:
#         params_file = output_path('MC_Bd2JpsiKstar/mass_prefit_{year}/mass_fit_params_{year}.json'),
#         plots = directory(output_path('MC_Bd2JpsiKstar/mass_prefit_{year}/plots/'))
#     shell:
#         'python {input.script} --input-file {input.root_file} \
#                                --fit-result-file {output.params_file} \
#                                --mode MC_Bd2JpsiKstar \
#                                --trigcat \
#                                --plots-loc {output.plots}'
#
# rule select_jpsikstar_mc_for_acc:
#     """
#     Select B0->J/psiK* MC for time acceptance. It includes B_BKGCAT=0,50,60 candidates.
#     """
#     input:
# #        root_file = expand(rules.apply_background_veto.output, mode='MC_Bd2JpsiKstar',
# #                                                             year='{year}'),
#         script = 'selection/tools/apply_selection.py',
#         cuts = 'time_acceptance/cuts.yaml'
#     output:
#         tuples_path('{mode}/{mode}_{year}_mc_for_fit_acc.root')
#     params:
#         root_file = lambda wildcards: selconfig['eos'] + '/' + selconfig['version'] + '/{}/{}/{}_{}_selected_bdt_{}.root'.format('MC_Bd2JpsiKstar', wildcards.year, 'MC_Bd2JpsiKstar', wildcards.year, selconfig['version']),
#         cut_keys = 'B_cuts_acc Kstar_cuts_acc'
#     shell:
#         'python {input.script} --input-file {params.root_file} \
#                                --output-file {output} \
#                                --mode {wildcards.mode} \
#                                --selection-files {input.cuts} \
#                                --cut-keys {params.cut_keys} \
#                                --year {wildcards.year}'
#
# rule mass_fit_jpsikstar_data:
#     """
#     Run mass fit on selected B0->J/psiK* data fixing Ipatia tail parameters for
#     the fit to mc with B_BKGCAT=0,50.
#     """
#     input:
#         script = 'selection/tools/mass_fit_ipatia.py',
#         root_file = expand(rules.select_jpsikstar_data_for_acc.output, mode='Bd2JpsiKstar',
#                                                              year='{year}'),
#         params_file = expand(rules.mass_prefit_jpsikstar_mc.output.params_file, year='{year}')
#     output:
#         root_file = tuples_path('Bd2JpsiKstar/Bd2JpsiKstar_{year}_selected_bdt_sw.root'),
#         plots = directory(output_path('Bd2JpsiKstar/mass_fit_{year}/plots/')),
#         params_file = output_path('Bd2JpsiKstar/mass_fit_{year}/mass_fit_params_{year}.json'),
#         root_file_tmp = temp(output_path('Bd2JpsiKstar/mass_fit_{year}.root'))
#     params:
#         params_to_fix = ['alpha1', 'alpha2', 'n1', 'n2']
#     shell:
#         'python {input.script} --input-file {input.root_file} \
#                                --output-file-tmp {output.root_file_tmp} \
#                                --output-file {output.root_file} \
#                                --mode Bd2JpsiKstar \
#                                --trigcat \
#                                --params-to-fix-file {input.params_file} \
#                                --params-to-fix-list {params.params_to_fix} \
#                                --background \
#                                --fit-result-file {output.params_file} \
#                                --plots-loc {output.plots} \
#                                --add-sweights '
#
# rule mass_fit_jpsikstar_mc:
#     """
#     Run MC fit on selected B0->J/psiK* MC with B_BKGCAT=0,50,60 fixing Ipatia tail parameters for
#     the fit to mc with B_BKGCAT=0,50.
#     """
#     input:
#         script = 'selection/tools/mass_fit_ipatia.py',
#         root_file = expand(rules.select_jpsikstar_mc_for_acc.output, mode='MC_Bd2JpsiKstar',
#                                                              year='{year}'),
#         params_file = expand(rules.mass_prefit_jpsikstar_mc.output.params_file, year='{year}')
#     output:
#         root_file = tuples_path('MC_Bd2JpsiKstar/MC_Bd2JpsiKstar_{year}_selected_bdt_sw.root'),
#         plots = directory(output_path('MC_Bd2JpsiKstar/mass_fit_{year}/plots/')),
#         params_file = output_path('MC_Bd2JpsiKstar/mass_fit_{year}/mass_fit_params_{year}.json'),
#         root_file_tmp = temp(output_path('MC_Bd2JpsiKstar/mass_fit_{year}.root'))
#     params:
#         params_to_fix = ['alpha1', 'alpha2', 'n1', 'n2']
#     shell:
#         'python {input.script} --input-file {input.root_file} \
#                                --output-file-tmp {output.root_file_tmp} \
#                                --output-file {output.root_file} \
#                                --mode MC_Bd2JpsiKstar \
#                                --trigcat \
#                                --params-to-fix-file {input.params_file} \
#                                --params-to-fix-list {params.params_to_fix} \
#                                --background \
#                                --fit-result-file {output.params_file} \
#                                --plots-loc {output.plots} \
#                                --add-sweights '
#
#
# rule select_jpsikplus_mc_for_prefit_and_tagging:
#     """
#     Select B+->J/psiK+ MC for tagging studies and to determine Ipatia tail parameters for
#     the fit to data. It only takes B_BKGCAT=0,50 events.
#     """
#     input:
# #        root_file = expand(rules.apply_background_veto.output, mode='MC_Bu2JpsiKplus', year='{year}'),
#         script = 'selection/tools/apply_selection.py'
#     output:
#         root_file = tuples_path('MC_Bu2JpsiKplus/MC_Bu2JpsiKplus_{year}_selected_bdt_bkgcat_0_50.root')
#     params:
#         root_file = lambda wildcards: selconfig['eos'] + '/' + selconfig['version'] + '/{}/{}/{}_{}_selected_bdt_{}.root'.format('MC_Bu2JpsiKplus', wildcards.year, 'MC_Bu2JpsiKplus', wildcards.year, selconfig['version']),
#         cut = 'B_BKGCAT == 0 || (B_BKGCAT == 50 && B_TRUETAU > 0)'
#     shell:
#         'python {input.script} --input-file {params.root_file} \
#                                --output-file {output} \
#                                --mode MC_Bu2JpsiKplus \
#                                --cut-string "{params.cut}" \
#                                --year {wildcards.year}'
#
# rule mass_prefit_jpsikplus_mc:
#     """
#     Run mass fit on bdt selected B+->J/psiK+ MC to determine Ipatia tail parameters for
#     the fit to data. It only takes B_BKGCAT=0,50 candidates.
#     """
#     input:
#         script = 'selection/tools/mass_fit_ipatia.py',
#         root_file = expand(rules.select_jpsikplus_mc_for_prefit_and_tagging.output, year='{year}')
#     output:
#         params_file = output_path('MC_Bu2JpsiKplus/mass_final_prefit_{year}/mass_fit_params_{year}.json'),
#         plots = directory(output_path('MC_Bu2JpsiKplus/mass_final_prefit_{year}/plots/'))
#     shell:
#         'python {input.script} --input-file {input.root_file} \
#                                --fit-result-file {output.params_file} \
#                                --mode MC_Bu2JpsiKplus \
#                                --trigcat \
#                                --plots-loc {output.plots}'
#
#
# rule mass_fit_jpsikplus_data:
#     """
#     Run mass fit on selected B+->J/psiK+ data fixing Ipatia tail parameters for
#     the fit to mc with B_BKGCAT=0,50.
#     """
#     input:
#         script = 'selection/tools/mass_fit_ipatia.py',
# #        root_file = expand(rules.apply_background_veto.output, mode='Bu2JpsiKplus',
# #                                                      year='{year}'),
#         params_file = expand(rules.mass_prefit_jpsikplus_mc.output.params_file, year='{year}')
#     output:
#         root_file = tuples_path('Bu2JpsiKplus/Bu2JpsiKplus_{year}_selected_bdt_sw.root'),
#         plots = directory(output_path('Bu2JpsiKplus/mass_fit_{year}/plots/')),
#         params_file = output_path('Bu2JpsiKplus/mass_fit_{year}/mass_fit_params_{year}.json'),
#         root_file_tmp = temp(output_path('Bu2JpsiKplus/mass_fit_{year}.root'))
#     params:
#         root_file = lambda wildcards: selconfig['eos'] + '/' + selconfig['version'] + '/{}/{}/{}_{}_selected_bdt_{}.root'.format('Bu2JpsiKplus', wildcards.year, 'Bu2JpsiKplus', wildcards.year, selconfig['version']),
#         params_to_fix = ['alpha1', 'alpha2', 'n1', 'n2']
#     shell:
#         'python {input.script} --input-file {params.root_file} \
#                                --output-file-tmp {output.root_file_tmp} \
#                                --output-file {output.root_file} \
#                                --mode Bu2JpsiKplus \
#                                --trigcat \
#                                --params-to-fix-file {input.params_file} \
#                                --params-to-fix-list {params.params_to_fix} \
#                                --background \
#                                --fit-result-file {output.params_file} \
#                                --plots-loc {output.plots} \
#                                --add-sweights '
#
# rule select_jpsikplus_mc_bkgcat_0_50_60:
#     """
#     Select B+->J/psiK+ MC with B_BKGCAT=0,50,60 events.
#     """
#     input:
# #        root_file = expand(rules.apply_background_veto.output, mode='MC_Bu2JpsiKplus', year='{year}'),
#         script = 'selection/tools/apply_selection.py'
#     output:
#         root_file = tuples_path('MC_Bu2JpsiKplus/MC_Bu2JpsiKplus_{year}_selected_bdt_bkgcat_0_50_60.root')
#     params:
#         root_file = lambda wildcards: selconfig['eos'] + '/' + selconfig['version'] + '/{}/{}/{}_{}_selected_bdt_{}.root'.format('MC_Bu2JpsiKplus', wildcards.year, 'MC_Bu2JpsiKplus', wildcards.year, selconfig['version']),
#         cut = 'B_BKGCAT == 0 || (B_BKGCAT == 50 && B_TRUETAU > 0) || B_BKGCAT == 60'
#     shell:
#         'python {input.script} --input-file {params.root_file} \
#                                --output-file {output} \
#                                --mode MC_Bu2JpsiKplus \
#                                --cut-string "{params.cut}" \
#                                --year {wildcards.year}'
#
#
# rule mass_fit_jpsikplus_mc:
#     """
#     Run MC fit on selected B+->J/psiK+ MC with B_BKGCAT=0,50,60 fixing Ipatia tail parameters for
#     the fit to mc with B_BKGCAT=0,50.
#     """
#     input:
#         script = 'selection/tools/mass_fit_ipatia.py',
#         root_file = expand(rules.select_jpsikplus_mc_bkgcat_0_50_60.output, mode='MC_Bu2JpsiKplus',
#                                                              year='{year}'),
#         params_file = expand(rules.mass_prefit_jpsikplus_mc.output.params_file, year='{year}')
#     output:
#         root_file = tuples_path('MC_Bu2JpsiKplus/MC_Bu2JpsiKplus_{year}_selected_bdt_sw.root'),
#         plots = directory(output_path('MC_Bu2JpsiKplus/mass_fit_{year}/plots/')),
#         params_file = output_path('MC_Bu2JpsiKplus/mass_fit_{year}/mass_fit_params_{year}.json'),
#         root_file_tmp = temp(output_path('MC_Bu2JpsiKplus/mass_fit_{year}.root'))
#     params:
#         params_to_fix = ['alpha1', 'alpha2', 'n1', 'n2']
#     shell:
#         'python {input.script} --input-file {input.root_file} \
#                                --output-file-tmp {output.root_file_tmp} \
#                                --output-file {output.root_file} \
#                                --mode MC_Bu2JpsiKplus \
#                                --trigcat \
#                                --params-to-fix-file {input.params_file} \
#                                --params-to-fix-list {params.params_to_fix} \
#                                --background \
#                                --fit-result-file {output.params_file} \
#                                --plots-loc {output.plots} \
#                                --add-sweights '
# }}}


# vim: fdm=marker
