# TIME RESOLUTION
#
#
#


# Time resolution basics {{{
#    This rule copies Csp factors from analysis/params and places them according
#    to the name of the output.

rule time_resolution_basics:
  wildcard_constraints:
    timeres = "(none|old)"
  output:
    "output/params/time_resolution/{year}/{mode}/{version}_{timeres}.json",
  run:
    import os
    res = "analysis/params/time_resolution/{wildcards.mode}/{wildcards.timeres}.json"
    shell(f"mkdir -p {os.path.dirname(f'{output}')}")
    shell(f"cp {res} {output}")


rule time_resolution_offset:
  output:
    "output/params/time_offset/{year}/{mode}/{version}_{timeres}.json",
  run:
    import os
    from ipanema import Parameters
    mode = f"{wildcards.mode}"
    year = f"{wildcards.year}"
    pars = Parameters.load(f"analysis/params/time_resolution/{mode}/none.json")
    output_file = f"{output}"

    # TODO: this should be either computed withing this analysis pipeline or
    # moved elsewhere
    meson = {
        "Bs2JpsiPhi": {
           '2015': -4.853652301889032,
           '2016': -6.122278950797789,
           '2017': -7.130933450563839,
           '2018': -5.870099929940548
        },
        "Bd2JpsiKstar": {
            '2015': -4.853652301889032,
            '2016': -6.122278950797789,
            '2017': -7.130933450563839,
            '2018': -5.870099929940548
        }
    }

    if not "v0r0" in f"{wildcards.version}":
        if mode in meson.keys():
            pars['mu'].set(value=meson[mode][year])
    print(pars)
    pars.dump(output_file)

# }}}


# Time resolution from git {{{
#    Currently time resolution is only computed at NIKHEF, hence we need to sync
#    it from there.

rule time_resolution_from_git:
  threads: 128
  wildcard_constraints:
    timeres = "ams(rd|mc|dg0)"
  input:
    "output/params/time_offset/{year}/{mode}/{version}_{timeres}.json",
  params:
    repo = "ssh://git@gitlab.cern.ch:7999/lhcb-b2cc/Bs2JpsiPhi-FullRun2.git",
    linker = "analysis/params/time_resolution/linker.json"
  output:
    "output/params/time_resolution/{year}/{mode}/{version}_{timeres}.json",
  log:
    "output/log/time_resolution_from_git/{year}/{mode}/{version}_{timeres}.log",
  run:
    shell(f"""(time\
    python analysis/time_resolution/download_from_git.py\
    --year {wildcards.year}\
    --mode {wildcards.mode}\
    --version v1r0\
    --timeres {wildcards.timeres}\
    --output {output}\
    --repo {params.repo}\
    --linker {params.linker}\
    ) #&> {log}""")
    # TODO: move this to the script itself / create another rule to merge time
    # resolution and time offset
    import ipanema
    res = ipanema.Parameters.load(f"{output}")
    off = ipanema.Parameters.load(f"{input}")
    res['mu'].set(value=off['mu'].value, stdev=off['mu'].stdev)
    res.dump(f"{output}")

# }}}


# for the future
# es el modo: Bs2JpsiPhi_Prompt_mixPV
# en teoria solo tiene WPV
rule time_resolution_wpv_shape:
    input:
        data = lambda wcs: tuples(wcs, mode='Bs2JpsiPhi_Prompt_mixPV', weight='chopped')
    output:
        plots = directory('output/figures/wpv_shape/{year}/Bs2JpsiPhi_Prompt_mixPV/{version}_{wpv}_{trigger}'),
        json = 'output/params/wpv_shape/{year}/Bs2JpsiPhi_Prompt_mixPV/{version}_{wpv}_{trigger}.json'
    params:
        script = 'analysis/time_resolution/wrong_pv_component.py',
    log:
        'output/params/wpv_shape/{year}/Bs2JpsiPhi_Prompt_mixPV/{version}_{wpv}_{trigger}.log'
    run:
        shell(f"""(time\
        python {params.script} \
        --data-in {input.data} \
        --wpv {wildcards.wpv} \
        --wpv-out {output.json} \
        --plots-out {output.plots} \
        ) &> {log}""")


rule time_resolution_calculate_gb_weights:
    input:
        mc = lambda wcs: tuples(wcs, mode='MC_Bs2JpsiPhi_Prompt', weight='chopped'),
        rd = lambda wcs: tuples(wcs, mode='Bs2JpsiPhi_Prompt', weight='chopped'),
        # target_file = lambda wildcards: XRootD.remote(expand(files_from_configuration('{}'.format( 'Bs_sw' if wildcards.label == 'MC_Bs' else 'Bs_prompt')), year = '{year}')),
        # files = lambda wildcards: XRootD.remote(expand(files_from_configuration('{}'.format(wildcards.label)), year = '{year}'))
    output:
        SAMPLES+'/{year}/MC_Bs2JpsiPhi_Prompt/{version}_gbWeight.root'
    params:
        script = 'analysis/time_resolution/reweighter.py',
    run:
        shell('python {params.script} --original-file {input.mc} \
                               --target-file {input.rd} \
                               --mode MC_Bs2JpsiPhi_Prompt \
                               --output-file {output}')


rule time_resolution_prompt:
    wildcard_constraints:
        mode = '(MC_)?Bs2JpsiPhi_Prompt'
    input:
        # TODO: create a wpv_shape guesser
        wpv_shape = 'output/params/wpv_shape/{year}/Bs2JpsiPhi_Prompt_mixPV/{version}_classical10_{trigger}.json',
        data = lambda wcs: tuples(wcs, weight='chopped'),
    output:
        plots = directory('output/figures/time_resolution_fit/{year}/{mode}/{version}_{timeres}_{trigger}'),
        json = 'output/params/time_resolution_fit/{year}/{mode}/{version}_{timeres}_{trigger}.json',
        #       output/params/time_resolution/Bs2JpsiPhi_Prompt/v0r5_doubleClassical10_combined.json
        data_ll = SAMPLES+'/{year}/{mode}/{version}_llComponent~{timeres}~{trigger}.npy'
    params:
        script = 'analysis/time_resolution/script1.py',
    log:
        'output/params/time_resolution_fit/{year}/{mode}/{version}_{timeres}_{trigger}.log'
    run:
        shell(f"""(time\
        python {params.script}\
        --in-data {input.data} \
        --timeres {wildcards.timeres} \
        --in-wpv {input.wpv_shape} \
        --out-json {output.json} \
        --out-plots {output.plots} \
        --out-data {output.data_ll} \
        ) &> {log}""")


rule time_resolution_signal:
    wildcard_constraints:
        mode = 'MC_Bs2JpsiPhi'
    input:
        # TODO: create a wpv_shape guesser
        wpv_shape = 'output/params/wpv_shape/{year}/Bs2JpsiPhi_Prompt_mixPV/{version}_classical10_{trigger}.json',
        # data = XRootD.remote("root://eoslhcb.cern.ch//eos/lhcb/wg/B2CC/Bs2JpsiPhi-FullRun2/v0r5/OSCombined_Tuple/MC_Bs2JpsiPhi_comb/MC_Bs2JpsiPhi_2018_selected_bdt_v0r5.root"),
        data = lambda wcs: tuples(wcs, weight='ready'),
    output:
        plots = directory('output/figures/time_resolution_fit/{year}/{mode}/{version}_{timeres}_{trigger}'),
        json = 'output/params/time_resolution_fit/{year}/{mode}/{version}_{timeres}_{trigger}.json',
        #       output/params/time_resolution/Bs2JpsiPhi_Prompt/v0r5_doubleClassical10_combined.json
        data_ll = SAMPLES+'/{year}/{mode}/{version}_llComponent~{timeres}~{trigger}.npy'
    params:
        script = 'analysis/time_resolution/script1.py',
    log:
        'output/params/time_resolution_fit/{year}/{mode}/{version}_{timeres}_{trigger}.log'
    run:
        shell(f"""(time\
        python {params.script}\
        --in-data {input.data} \
        --timeres {wildcards.timeres} \
        --mode {wildcards.mode} \
        --in-wpv {input.wpv_shape} \
        --out-json {output.json} \
        --out-plots {output.plots} \
        --out-data {output.data_ll} \
        ) &> {log}""")


rule time_resolution_dilution_computation:
    wildcard_constraints:
        mode = '(MC_Bs2JpsiPhi(_Prompt)?|Bs2JpsiPhi_Prompt)',
        timeres = "(double)"
    input:
        # TODO: create a time_resolution_fit
        data = lambda wcs: tuples(wcs, weight='chopped'),
        json = expand('output/params/time_resolution_fit/{{year}}/{{mode}}/{{version}}_{{timeres}}{ibin}_{{trigger}}.json', ibin=range(1,10+1)),
        data_ll =                       expand(SAMPLES+'/{{year}}/{{mode}}/{{version}}_llComponent~{{timeres}}{ibin}~{{trigger}}.npy', ibin=range(1,10+1))
        #               /scratch46/marcos.romero/sidecar14/2015/Bs2JpsiPhi_Prompt/v0r5_llComponent~doubleClassical10bin3~combined.root
    output:
        json = 'output/params/time_resolution_dilution/{year}/{mode}/{version}_{timeres}_{trigger}.json',
        #       output/params/time_resolution_dilution/2015/Bs2JpsiPhi_Prompt/v0r5_doubleClassical10_combined.json
    params:
        script = 'analysis/time_resolution/compute_dilution.py',
    run:
        fpars = input.json
        fpars = [fpars] if isinstance(fpars,str) else fpars
        dlongl = input.json
        dlongl = [dlongl] if isinstance(dlongl,str) else dlongl
        # _in_json = ",".join(fpars)
        # print(_in_json)
        shell(f'python {params.script} --data-in {input.data} \
                               --data-ll {",".join(dlongl)} \
                               --timeres {wildcards.timeres} \
                               --mode {wildcards.mode} \
                               --json-in {",".join(fpars)} \
                               --json-out "{output.json}"')


rule time_resolution_calibration_numerical:
    wildcard_constraints:
        mode = '(MC_Bs2JpsiPhi(_Prompt)?|Bs2JpsiPhi_Prompt)',
        timeres = "(double)"
    input:
        data = lambda wcs: tuples(wcs, weight='chopped'),
        json_bin = expand('output/params/time_resolution_fit/{{year}}/{{mode}}/{{version}}_{{timeres}}{ibin}_combined.json', ibin=range(1,10+1)),
        json_num = 'output/params/time_resolution_dilution/{year}/{mode}/{version}_{timeres}_combined.json',
    output:
        plots = directory('output/figures/time_resolution/{year}/{mode}/{version}_{timeres}'),
        jsonLinear = 'output/params/time_resolution/{year}/{mode}/{version}_{timeres}Linear.json',
        jsonParab = 'output/params/time_resolution/{year}/{mode}/{version}_{timeres}Parab.json'
    params:
        script = 'analysis/time_resolution/calibration.py',
    log:
        'output/params/time_resolution/{year}/{mode}/{version}_{timeres}.log'
    run:
        fpars = input.json_bin
        fpars = [fpars] if isinstance(fpars,str) else fpars
        shell(f"""(time\
        python {params.script}\
        --in-data {input.data} \
        --timeres {wildcards.timeres}\
        --mode {wildcards.mode}\
        --in-json-bin {",".join(fpars)}\
        --in-json-num {input.json_num}\
        --out-json-linear {output.jsonLinear}\
        --out-json-parab {output.jsonParab}\
        --out-plot {output.plots}\
        ) &> {log}""")


rule time_resolution_dilution_translation:
    wildcard_constraints:
        mode = 'Bs2JpsiPhi'
    input:
        json_mc = 'output/params/time_resolution_dilution/{year}/MC_Bs2JpsiPhi/{version}_{timeres}_{trigger}.json',
        json_mc_prompt = 'output/params/time_resolution_dilution/{year}/MC_Bs2JpsiPhi_Prompt/{version}_{timeres}_{trigger}.json',
        json_rd_prompt = 'output/params/time_resolution_dilution/{year}/Bs2JpsiPhi_Prompt/{version}_{timeres}_{trigger}.json',
    output:
        json_rd = 'output/params/time_resolution_dilution/{year}/{mode}/{version}_{timeres}_{trigger}.json',
    params:
        script = 'analysis/time_resolution/translate.py',
    log:
        'output/params/time_resolution_dilution/{year}/{mode}/{version}_{timeres}_{trigger}.log'
    run:
        shell(f"""(time\
        python {params.script}\
        --timeres {wildcards.timeres}\
        --mode {wildcards.mode}\
        --in-json-mc {input.json_mc}\
        --in-json-mc-prompt {input.json_mc_prompt}\
        --in-json-rd-prompt {input.json_rd_prompt}\
        --out-json-rd {output.json_rd}\
        ) &> {log}""")


rule time_resolution_calibration_translate:
    wildcard_constraints:
        mode = 'Bs2JpsiPhi'
    input:
        data = lambda wcs: tuples(wcs, mode='Bs2JpsiPhi_Prompt', weight='chopped'),
        json_old = 'output/params/time_resolution_dilution/{year}/{mode}_Prompt/{version}_{timeres}_combined.json',
        json_trs = 'output/params/time_resolution_dilution/{year}/{mode}/{version}_{timeres}_combined.json',
    output:
        plots = directory('output/figures/time_resolution/{year}/{mode}/{version}_{timeres}'),
        jsonLinear = 'output/params/time_resolution/{year}/{mode}/{version}_{timeres}Linear.json',
        jsonParab = 'output/params/time_resolution/{year}/{mode}/{version}_{timeres}Parab.json'
    params:
        script = 'analysis/time_resolution/calibration.py',
    log:
        'output/log/time_resolution/{year}/{mode}/{version}_{timeres}.log'
    run:
        shell(f"""(time\
        python {params.script}\
        --in-data {input.data} \
        --timeres {wildcards.timeres}\
        --mode {wildcards.mode}\
        --in-json-bin {input.json_old}\
        --in-json-num {input.json_trs}\
        --out-json-linear {output.jsonLinear}\
        --out-json-parab {output.jsonParab}\
        --out-plot {output.plots}\
        ) &> {log}""")


# vim:foldmethod=marker
