# Run2 physics_params ----------------------------------------------------------
#     This rule runs the iterative procedure for FullRun2 years using RD.
from analysis.utils.strings import cammel_parser

rule physics_params_data_run2:
  input:
    samples = lambda wcs: tuples(wcs,mode='Bs2JpsiPhi',year='Run2'),
    # Angular acceptance
    angacc_biased = [
      'output/params/angular_acceptance/2015/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_biased.json',
      'output/params/angular_acceptance/2016/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_biased.json',
      'output/params/angular_acceptance/2017/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_biased.json',
      'output/params/angular_acceptance/2018/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_biased.json'
    ],
    angacc_unbiased = [
      'output/params/angular_acceptance/2015/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_unbiased.json',
      'output/params/angular_acceptance/2016/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_unbiased.json',
      'output/params/angular_acceptance/2017/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_unbiased.json',
      'output/params/angular_acceptance/2018/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_unbiased.json'
    ],
    # Time acceptance coefficients
    timeacc_biased = [
      'output/params/time_acceptance/2015/Bd2JpsiKstar/{version}_{timeacc}_biased.json',
      'output/params/time_acceptance/2016/Bd2JpsiKstar/{version}_{timeacc}_biased.json',
      'output/params/time_acceptance/2017/Bd2JpsiKstar/{version}_{timeacc}_biased.json',
      'output/params/time_acceptance/2018/Bd2JpsiKstar/{version}_{timeacc}_biased.json'
    ],
    timeacc_unbiased = [
      'output/params/time_acceptance/2015/Bd2JpsiKstar/{version}_{timeacc}_unbiased.json',
      'output/params/time_acceptance/2016/Bd2JpsiKstar/{version}_{timeacc}_unbiased.json',
      'output/params/time_acceptance/2017/Bd2JpsiKstar/{version}_{timeacc}_unbiased.json',
      'output/params/time_acceptance/2018/Bd2JpsiKstar/{version}_{timeacc}_unbiased.json'
    ],
    # CSP
    csp_factors = lambda wcs: [
      f'output/params/csp_factors/2015/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json',
      f'output/params/csp_factors/2016/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json',
      f'output/params/csp_factors/2017/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json',
      f'output/params/csp_factors/2018/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json'
    ],
    # Time resolution
    time_resolution = lambda wcs: [
      f'output/params/time_resolution/2015/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json',
      f'output/params/time_resolution/2016/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json',
      f'output/params/time_resolution/2017/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json',
      f'output/params/time_resolution/2018/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json'
    ],
    # Flavor tagging
    flavor = lambda wcs: [
      f'output/params/flavor_tagging/2015/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json',
      f'output/params/flavor_tagging/2016/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json',
      f'output/params/flavor_tagging/2017/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json',
      f'output/params/flavor_tagging/2018/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json'
    ],
  output:
    params = 'output/params/angular_fit/run2/Bs2JpsiPhi/{version}_run2_{angacc}_{timeacc}.json',
    tables = 'output/tables/angular_fit/run2/Bs2JpsiPhi/{version}_run2_{angacc}_{timeacc}.tex'
  log:
    'output/log/physics_params_data/run2/Bs2JpsiPhi/{version}_run2_{angacc}_{timeacc}.log'
  run:
    shell(f"""(time\
    python analysis/angular_fit/fit_test_data.py\
           --samples                 {",".join(input.samples)}\
           --angacc-biased           {",".join(input.angacc_biased)}\
           --angacc-unbiased         {",".join(input.angacc_unbiased)}\
           --timeacc-biased          {",".join(input.timeacc_biased)}\
           --timeacc-unbiased        {",".join(input.timeacc_unbiased)}\
           --csp                     {",".join(input.csp_factors)}\
           --time-resolution         {",".join(input.time_resolution)}\
           --flavor-tagging          {",".join(input.flavor)}\
           --params                  {output.params}\
           --tables                  {output.tables}\
           --year                    {",".join(YEARS['Run2'])}\
           --flag                    run2_{wildcards.angacc}_{wildcards.timeacc}\
           --version                 {wildcards.version}\
    ) &> {log} #2>&1""")
    send_mail(f"Run2 Fit", f"{log}")








# Run2a angular acceptance -----------------------------------------------------
#     This rule runs the iterative procedure for Run2a years (2015&2016) using
#     both MC and MC_dG0 files.
rule physics_params_data_run2a:
  input:
    samples = lambda wcs: tuples(wcs,mode='Bs2JpsiPhi',year='Run2a'),
    # Angular acceptance
    angacc_biased = [
      'output/params/angular_acceptance/2015/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_biased.json',
      'output/params/angular_acceptance/2016/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_biased.json'
    ],
    angacc_unbiased = [
      'output/params/angular_acceptance/2015/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_unbiased.json',
      'output/params/angular_acceptance/2016/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_unbiased.json'
    ],
    # Time acceptance coefficients
    timeacc_biased = [
      'output/params/time_acceptance/2015/Bd2JpsiKstar/{version}_{timeacc}_biased.json',
      'output/params/time_acceptance/2016/Bd2JpsiKstar/{version}_{timeacc}_biased.json'
    ],
    timeacc_unbiased = [
      'output/params/time_acceptance/2015/Bd2JpsiKstar/{version}_{timeacc}_unbiased.json',
      'output/params/time_acceptance/2016/Bd2JpsiKstar/{version}_{timeacc}_unbiased.json'
    ],
    # CSP
    csp_factors = lambda wcs: [
      f'output/params/csp_factors/2015/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json',
      f'output/params/csp_factors/2016/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json'
    ],
    # Time resolution
    time_resolution = lambda wcs: [
      f'output/params/time_resolution/2015/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json',
      f'output/params/time_resolution/2016/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json'
    ],
    # Flavor tagging
    flavor = lambda wcs: [
      f'output/params/flavor_tagging/2015/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json',
      f'output/params/flavor_tagging/2016/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json'
    ],
  output:
    params = 'output/params/angular_fit/run2a/Bs2JpsiPhi/{version}_run2a_{angacc}_{timeacc}.json',
    tables = 'output/tables/angular_fit/run2a/Bs2JpsiPhi/{version}_run2a_{angacc}_{timeacc}.tex'
  log:
    'output/log/angular_acceptance/physics_params/run2a/Bs2JpsiPhi/{version}_{angacc}_{timeacc}.log'
  run:
    shell(f"""(time\
    python analysis/angular_fit/fit_test_data.py\
           --samples                 {",".join(input.samples)}\
           --angacc-biased           {",".join(input.angacc_biased)}\
           --angacc-unbiased         {",".join(input.angacc_unbiased)}\
           --timeacc-biased          {",".join(input.timeacc_biased)}\
           --timeacc-unbiased        {",".join(input.timeacc_unbiased)}\
           --csp                     {",".join(input.csp_factors)}\
           --time-resolution         {",".join(input.time_resolution)}\
           --flavor-tagging          {",".join(input.flavor)}\
           --params                  {output.params}\
           --tables                  {output.tables}\
           --year                    {",".join(yd['Run2a'])}\
           --cuts                    '{cammel_parser(wildcards.timeacc)}'\
           --version                 {wildcards.version}\
    ) &> {log} #2>&1""")
    send_mail(f"Physics Parameters Run2a", f"{log}")




# Yearly time-dependent angular fit --------------------------------------------
#     This rule runs the iterative procedure for Run2a years (2015&2016) using
#     both MC and MC_dG0 files.
rule physics_params_dataYearly:
  input:
    samples = lambda wcs: [tuples(wcs,mode='Bs2JpsiPhi')],
    # Angular acceptance
    angacc_biased = [
      'output/params/angular_acceptance/{year}/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_biased.json'
    ],
    angacc_unbiased = [
      'output/params/angular_acceptance/{year}/Bs2JpsiPhi/{version}_{angacc}_{timeacc}_unbiased.json'
    ],
    # Time acceptance coefficients
    timeacc_biased = [
      'output/params/time_acceptance/{year}/Bd2JpsiKstar/{version}_{timeacc}_biased.json'
    ],
    timeacc_unbiased = [
      'output/params/time_acceptance/{year}/Bd2JpsiKstar/{version}_{timeacc}_unbiased.json'
    ],
    # CSP
    csp_factors = lambda wcs: [
      f'output/params/csp_factors/{wcs.year}/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json'
    ],
    # Time resolution
    time_resolution = lambda wcs: [
      f'output/params/time_resolution/{wcs.year}/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json'
    ],
    # Flavor tagging
    flavor = lambda wcs: [
      f'output/params/flavor_tagging/{wcs.year}/Bs2JpsiPhi/{wcs.version.split("@")[0]}.json'
    ],
  output:
    params = 'output/params/angular_fit/{year}/Bs2JpsiPhi/{version}_yearly_{angacc}_{timeacc}.json',
    tables = 'output/tables/angular_fit/{year}/Bs2JpsiPhi/{version}_yearly_{angacc}_{timeacc}.tex'
  log:
    'output/log/angular_acceptance/physics_params/{year}/Bs2JpsiPhi/{version}_{angacc}_{timeacc}.log'
  run:
    shell(f"""(time\
    python analysis/angular_fit/fit_test_data.py\
           --samples                 {",".join(input.samples)}\
           --angacc-biased           {",".join(input.angacc_biased)}\
           --angacc-unbiased         {",".join(input.angacc_unbiased)}\
           --timeacc-biased          {",".join(input.timeacc_biased)}\
           --timeacc-unbiased        {",".join(input.timeacc_unbiased)}\
           --csp                     {",".join(input.csp_factors)}\
           --time-resolution         {",".join(input.time_resolution)}\
           --flavor-tagging          {",".join(input.flavor)}\
           --params                  {output.params}\
           --tables                  {output.tables}\
           --year                    {",".join([wildcards.year])}\
           --version                 {wildcards.version}\
           --cuts                    '{cammel_parser(wildcards.timeacc)}'\
    ) #&> {log} #2>&1""")
    send_mail(f"Physics Parameters Run2a", f"{log}")













# Run2a angular acceptance -----------------------------------------------------
#     This rule runs the iterative procedure for Run2a years (2015&2016) using
#     both MC and MC_dG0 files.
rule physics_params_mc:
  wildcard_constraints:
    mode = "(TOY|MC)_(Bs2JpsiPhi(_dG0)?|Bs2JpsiKK_Swave)"
  input:
    samples = lambda wcs: [tuples(wcs)],
    # CSP
    csp_factors = lambda wcs: [
      f'output/params/csp_factors/{wcs.year}/{wcs.mode}/{wcs.version.split("@")[0]}.json',
    ],
  output:
    params = 'output/params/angular_fit/{year}/{mode}/{version}_base.json',
    tables = 'output/tables/angular_fit/{year}/{mode}/{version}_base.tex'
  log:
    'output/log/angular_acceptance/physics_params_mc/{year}/{mode}/{version}.log'
  run:
    shell(f"""(time\
    python analysis/angular_fit/fit_test_mc.py\
           --samples                 {",".join(input.samples)}\
           --csp                     {",".join(input.csp_factors)}\
           --params                  {output.params}\
           --tables                  {output.tables}\
           --year                    {",".join([wildcards.year])}\
           --version                 {wildcards.version}\
    ) #&> {log} #2>&1""")
    send_mail(f"Run2a Fit", f"{log}")


rule physics_params_mcfit_vs_mcgen:
  wildcard_constraints:
    mode = "(TOY|MC)_(Bs2JpsiPhi(_dG0)?|Bs2JpsiKK_Swave)"
  input:
    fit = 'output/params/angular_fit/{year}/{mode}/{version}_base.json',
    gen = 'analysis/params/generator/2018/{mode}.json'
  output:
    tables = 'output/tables/angular_fit/{year}/{mode}/{version}_base_comparisonFitGen.tex'
  log:
    'output/log/angular_fit/physics_params_mcfit_vs_mcgen/{year}/{mode}/{version}_base.log'
  run:
    from ipanema import Parameters
    fit = Parameters.load(f'{input.fit}')
    gen = Parameters.load(f'{input.gen}')
    table = []
    table.append(f' {"Parameter":>30}  &  {"Fit":>20}  &  {"Gen":>7}  &  {"Pull":>4}')
    for par in fit.keys():
      if par in gen.keys():
        table.append(f'${fit[par].latex:>30} $&$ {f"{fit[par].uvalue:.2uL}":>25} $&$ {gen[par].value:+.4f} $&$ {(fit[par].value-gen[par].value)/fit[par].stdev if fit[par].stdev else 0:+.1f}')
      else:
        table.append(f'${fit[par].latex:>30} $&$ {f"{fit[par].uvalue:.2uL}":>25}')
    print(" \\\\ \n".join(table))
    with open(f'{output}','w') as f:
      f.write("\n".join(table))
    f.close()
