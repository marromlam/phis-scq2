# TIME RESOLUTION
#
#
#


# Time resolution basics {{{
#    This rule copies Csp factors from analysis/params and places them according
#    to the name of the output.

rule time_resolution_basics:
  wildcard_constraints:
    timeres = "(none|old)"
  output:
    "output/params/time_resolution/{year}/{mode}/{version}_{timeres}.json",
  run:
    import os
    res = "analysis/params/time_resolution/{wildcards.mode}/{wildcards.timeres}.json"
    shell(f"mkdir -p {os.path.dirname(f'{output}')}")
    shell(f"cp {res} {output}")

# }}}


# Time resolution from git {{{
#    Currently time resolution is only computed at NIKHEF, hence we need to sync
#    it from there.

rule time_resolution_from_git:
  threads: 128
  wildcard_constraints:
    timeres = "ams(rd|mc|dg0)"
  params:
    repo = "ssh://git@gitlab.cern.ch:7999/lhcb-b2cc/Bs2JpsiPhi-FullRun2.git",
    linker = "analysis/params/time_resolution/linker.json"
  output:
    "output/params/time_resolution/{year}/{mode}/{version}_{timeres}.json",
  log:
    "output/log/time_resolution_from_git/{year}/{mode}/{version}_{timeres}.log",
  run:
    shell(f"""(time\
    python analysis/time_resolution/download_from_git.py\
    --year {wildcards.year}\
    --mode {wildcards.mode}\
    --version v0r5\
    --timeres {wildcards.timeres}\
    --output {output}\
    --repo {params.repo}\
    --linker {params.linker}\
    ) &> {log}""")

# }}}


# for the future
# es el modo: Bs2JpsiPhi_Prompt_mixPV
# en teoria solo tiene WPV
rule time_resolution_wpv_shape:
    input:
        data = lambda wcs: tuples(wcs, mode='Bs2JpsiPhi_Prompt_mixPV', weight='chopped')
    output:
        plots = directory('output/figures/wpv_shape/{year}/Bs2JpsiPhi_Prompt_mixPV/{version}_{wpv}_{trigger}'),
        json = 'output/params/wpv_shape/{year}/Bs2JpsiPhi_Prompt_mixPV/{version}_{wpv}_{trigger}.json'
    params:
        script = 'analysis/time_resolution/wrong_pv_component.py',
    log:
        'output/params/wpv_shape/{year}/Bs2JpsiPhi_Prompt_mixPV/{version}_{wpv}_{trigger}.log'
    run:
        shell(f"""(time\
        python {params.script} \
        --data-in {input.data} \
        --wpv {wildcards.wpv} \
        --wpv-out {output.json} \
        --plots-out {output.plots} \
        ) &> {log}""")


rule time_resolution_calculate_gb_weights:
    input:
        mc = lambda wcs: tuples(wcs, mode='MC_Bs2JpsiPhi_Prompt', weight='chopped'),
        rd = lambda wcs: tuples(wcs, mode='Bs2JpsiPhi_Prompt', weight='chopped'),
        # target_file = lambda wildcards: XRootD.remote(expand(files_from_configuration('{}'.format( 'Bs_sw' if wildcards.label == 'MC_Bs' else 'Bs_prompt')), year = '{year}')),
        # files = lambda wildcards: XRootD.remote(expand(files_from_configuration('{}'.format(wildcards.label)), year = '{year}'))
    output:
        SAMPLES+'/{year}/MC_Bs2JpsiPhi_Prompt/{version}_gbWeight.root'
    params:
        script = 'analysis/time_resolution/reweighter.py',
    run:
        shell('python {params.script} --original-file {input.mc} \
                               --target-file {input.rd} \
                               --mode MC_Bs2JpsiPhi_Prompt \
                               --output-file {output}')


rule time_resolution_prompt:
    wildcard_constraints:
        mode = '(MC_)?Bs2JpsiPhi_Prompt'
    input:
        # TODO: create a wpv_shape guesser
        wpv_shape = 'output/params/wpv_shape/{year}/Bs2JpsiPhi_Prompt_mixPV/{version}_classical10_{trigger}.json',
        data = lambda wcs: tuples(wcs, weight='chopped'),
    output:
        plots = directory('output/figures/time_resolution_fit/{year}/{mode}/{version}_{timeres}_{trigger}'),
        json = 'output/params/time_resolution_fit/{year}/{mode}/{version}_{timeres}_{trigger}.json',
        #       output/params/time_resolution/Bs2JpsiPhi_Prompt/v0r5_doubleClassical10_combined.json
        data_ll = SAMPLES+'/{year}/{mode}/{version}_llComponent~{timeres}~{trigger}.npy'
    params:
        script = 'analysis/time_resolution/script1.py',
    log:
        'output/params/time_resolution_fit/{year}/{mode}/{version}_{timeres}_{trigger}.log'
    run:
        shell(f"""(time\
        python {params.script}\
        --in-data {input.data} \
        --timeres {wildcards.timeres} \
        --in-wpv {input.wpv_shape} \
        --out-json {output.json} \
        --out-plots {output.plots} \
        --out-data {output.data_ll} \
        ) &> {log}""")


rule time_resolution_compute_dilution:
    wildcard_constraints:
        mode = '(MC_)?Bs2JpsiPhi_Prompt',
        timeres = "(double)"
    input:
        # TODO: create a time_resolution_fit
        data = lambda wcs: tuples(wcs, weight='gbWeight'),
        json = expand('output/params/time_resolution_fit/{{year}}/{{mode}}/{{version}}_{{timeres}}{ibin}_{{trigger}}.json', ibin=range(1,10+1)),
        data_ll =                       expand(SAMPLES+'/{{year}}/{{mode}}/{{version}}_llComponent~{{timeres}}{ibin}~{{trigger}}.npy', ibin=range(1,10+1))
        #               /scratch46/marcos.romero/sidecar14/2015/Bs2JpsiPhi_Prompt/v0r5_llComponent~doubleClassical10bin3~combined.root
    output:
        json = 'output/params/time_resolution_dilution/{year}/{mode}/{version}_{timeres}_{trigger}.json',
        #       output/params/time_resolution_dilution/2015/Bs2JpsiPhi_Prompt/v0r5_doubleClassical10_combined.json
    params:
        script = 'analysis/time_resolution/compute_dilution.py',
    run:
        fpars = input.json
        fpars = [fpars] if isinstance(fpars,str) else fpars
        dlongl = input.json
        dlongl = [dlongl] if isinstance(dlongl,str) else dlongl
        # _in_json = ",".join(fpars)
        # print(_in_json)
        shell(f'python {params.script} --data-in {input.data} \
                               --data-ll {",".join(dlongl)} \
                               --timeres {wildcards.timeres} \
                               --mode {wildcards.mode} \
                               --json-in {",".join(fpars)} \
                               --json-out "{output.json}"')


rule calibration_numerical:
    input:
        data = lambda wcs: tuples(wcs, weight='gbWeight'),
        json_bin = expand('output/params/time_resolution_fit/{{year}}/{{mode}}/{{version}}_{{timeres}}{ibin}_combined.json', ibin=range(1,10+1)),
        json_num = 'output/params/time_resolution_dilution/{year}/{mode}/{version}_{timeres}_combined.json',
    output:
        plots = directory('output/figures/time_resolution/{year}/{mode}/{version}_{timeres}'),
        json = 'output/params/time_resolution/{year}/{mode}/{version}_{timeres}.json'
    params:
        script = 'time_resolution/calibrate_numerical.py',
    log:
        'output/params/time_resolution/{year}/{mode}/{version}_{timeres}.log'
    run:
        fpars = input.json_bin
        fpars = [fpars] if isinstance(fpars,str) else fpars
        shell(f"""(time\
        python {params.script}\
        --in-data {input.data} \
        --timeres {wildcards.timeres}\
        --mode {wildcards.mode}\
        --json-in-bin {",".join(fpars)}\
        --json-in-num {input.json_num}\
        --out-json {output.json}\
        --out-plots {output.plots}\
        ) &> {log}""")


# vim:foldmethod=marker
